"""Base strategy class and common types."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

import pandas as pd


class Side(Enum):
    """Trade side."""

    LONG = "long"
    SHORT = "short"


class SignalType(Enum):
    """Signal type."""

    ENTRY = "entry"
    EXIT = "exit"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""

    timestamp: datetime
    symbol: str
    side: Side
    signal_type: SignalType
    price: float
    stop_loss: float | None = None
    take_profit: float | None = None
    confidence: float = 1.0
    metadata: dict = field(default_factory=dict)

    @property
    def risk_reward_ratio(self) -> float | None:
        """Calculate risk/reward ratio if stop and target are set."""
        if self.stop_loss and self.take_profit:
            risk = abs(self.price - self.stop_loss)
            reward = abs(self.take_profit - self.price)
            if risk > 0:
                return reward / risk
        return None


@dataclass
class StrategyResult:
    """Result of strategy evaluation."""

    signals: list[Signal]
    indicators: dict[str, pd.Series]
    metadata: dict = field(default_factory=dict)


class Strategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, name: str, symbol: str, timeframe: str = "1h"):
        self.name = name
        self.symbol = symbol
        self.timeframe = timeframe
        self.is_active = True

    @abstractmethod
    def evaluate(self, data: pd.DataFrame) -> StrategyResult:
        """Evaluate strategy on market data.

        Args:
            data: DataFrame with OHLCV columns

        Returns:
            StrategyResult with signals and indicator values
        """
        pass

    @abstractmethod
    def get_entry_signal(self, data: pd.DataFrame) -> Signal | None:
        """Check for entry signal on latest bar.

        Args:
            data: DataFrame with OHLCV columns

        Returns:
            Signal if entry conditions met, None otherwise
        """
        pass

    @abstractmethod
    def get_exit_signal(self, data: pd.DataFrame, position_side: Side) -> Signal | None:
        """Check for exit signal on latest bar.

        Args:
            data: DataFrame with OHLCV columns
            position_side: Current position side

        Returns:
            Signal if exit conditions met, None otherwise
        """
        pass

    def validate_data(self, data: pd.DataFrame, min_rows: int = 200) -> bool:
        """Validate input data for strategy."""
        required = ["open", "high", "low", "close", "volume"]
        if not all(col in data.columns for col in required):
            return False
        if len(data) < min_rows:
            return False
        return True

    def calculate_position_size(
        self, account_value: float, risk_percent: float, entry: float, stop_loss: float
    ) -> float:
        """Calculate position size based on risk parameters.

        Args:
            account_value: Total account value
            risk_percent: Percentage to risk (0.01 = 1%)
            entry: Entry price
            stop_loss: Stop loss price

        Returns:
            Position size in base currency
        """
        risk_amount = account_value * risk_percent
        stop_distance = abs(entry - stop_loss)
        if stop_distance == 0:
            return 0
        return risk_amount / stop_distance

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(symbol={self.symbol}, timeframe={self.timeframe})"
